"use strict";(self.webpackChunkzig_colors_docs=self.webpackChunkzig_colors_docs||[]).push([[508],{5510:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"examples/real-world","title":"Real-World Examples","description":"Complete, practical examples showing how to use zig-colors in real applications.","source":"@site/versioned_docs/version-0.1.0/examples/real-world.md","sourceDirName":"examples","slug":"/examples/real-world","permalink":"/zig-colors-docs/examples/real-world","draft":false,"unlisted":false,"tags":[],"version":"0.1.0","sidebarPosition":3,"frontMatter":{"title":"Real-World Examples","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Advanced Styling","permalink":"/zig-colors-docs/examples/advanced-styling"}}');var l=t(4848),r=t(8453);const o={title:"Real-World Examples",sidebar_position:3},i="Real World Examples",c={},a=[{value:"Logger",id:"logger",level:2},{value:"Progress Bar",id:"progress-bar",level:2},{value:"Interactive Menu",id:"interactive-menu",level:2},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"real-world-examples",children:"Real World Examples"})}),"\n",(0,l.jsx)(n.p,{children:"Complete, practical examples showing how to use zig-colors in real applications."}),"\n",(0,l.jsx)(n.h2,{id:"logger",children:"Logger"}),"\n",(0,l.jsx)(n.p,{children:"A full-featured logger with different log levels and formatting:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-zig",children:'const std = @import("std");\nconst colors = @import("zig-colors");\n\npub const LogLevel = enum {\n    debug,\n    info,\n    warn,\n    err,\n    fatal,\n};\n\npub const Logger = struct {\n    level: LogLevel = .info,\n    show_timestamp: bool = true,\n    show_location: bool = false,\n\n    const Self = @This();\n\n    pub fn init() Self {\n        colors.init();\n        return Self{};\n    }\n\n    pub fn deinit() void {\n        colors.deinit();\n    }\n\n    pub fn debug(self: Self, comptime fmt: []const u8, args: anytype) void {\n        if (@intFromEnum(self.level) > @intFromEnum(LogLevel.debug)) return;\n        self.log(.debug, fmt, args);\n    }\n\n    pub fn info(self: Self, comptime fmt: []const u8, args: anytype) void {\n        if (@intFromEnum(self.level) > @intFromEnum(LogLevel.info)) return;\n        self.log(.info, fmt, args);\n    }\n\n    pub fn warn(self: Self, comptime fmt: []const u8, args: anytype) void {\n        if (@intFromEnum(self.level) > @intFromEnum(LogLevel.warn)) return;\n        self.log(.warn, fmt, args);\n    }\n\n    pub fn err(self: Self, comptime fmt: []const u8, args: anytype) void {\n        if (@intFromEnum(self.level) > @intFromEnum(LogLevel.err)) return;\n        self.log(.err, fmt, args);\n    }\n\n    pub fn fatal(self: Self, comptime fmt: []const u8, args: anytype) void {\n        self.log(.fatal, fmt, args);\n        std.process.exit(1);\n    }\n\n    fn log(self: Self, level: LogLevel, comptime fmt: []const u8, args: anytype) void {\n        const stdout = std.io.getStdOut().writer();\n\n        // Timestamp\n        if (self.show_timestamp) {\n            const timestamp = std.time.timestamp();\n            const style = colors.dim;\n            stdout.print("{} ", .{style.call("[2024-01-15 10:30:45]")}) catch return;\n        }\n\n        // Level badge\n        const level_style = switch (level) {\n            .debug => colors.magenta,\n            .info => colors.blue,\n            .warn => colors.yellow,\n            .err => colors.red,\n            .fatal => colors.white.bgRed().bold(),\n        };\n\n        const level_text = switch (level) {\n            .debug => "DEBUG",\n            .info => " INFO",\n            .warn => " WARN",\n            .err => "ERROR",\n            .fatal => "FATAL",\n        };\n\n        stdout.print("{} ", .{level_style.call(level_text)}) catch return;\n\n        // Message\n        stdout.print(fmt ++ "\\n", args) catch return;\n    }\n};\n\n// Usage example\npub fn main() !void {\n    var logger = Logger.init();\n    defer logger.deinit();\n\n    logger.debug("Starting application", .{});\n    logger.info("Server listening on port {d}", .{8080});\n    logger.warn("Cache miss for key: {s}", .{"user:123"});\n    logger.err("Failed to connect to database: {s}", .{"timeout"});\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"progress-bar",children:"Progress Bar"}),"\n",(0,l.jsx)(n.p,{children:"An animated progress bar with color transitions:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-zig",children:'const std = @import("std");\nconst colors = @import("zig-colors");\n\npub const ProgressBar = struct {\n    total: usize,\n    current: usize = 0,\n    width: usize = 40,\n    show_percentage: bool = true,\n    show_time: bool = true,\n    start_time: i64,\n\n    const Self = @This();\n\n    pub fn init(total: usize) Self {\n        return Self{\n            .total = total,\n            .start_time = std.time.milliTimestamp(),\n        };\n    }\n\n    pub fn update(self: *Self, current: usize) void {\n        self.current = current;\n        self.draw();\n    }\n\n    pub fn increment(self: *Self) void {\n        self.current += 1;\n        self.draw();\n    }\n\n    pub fn finish(self: *Self) void {\n        self.current = self.total;\n        self.draw();\n        std.debug.print("\\n", .{});\n    }\n\n    fn draw(self: Self) void {\n        const stdout = std.io.getStdOut().writer();\n\n        // Calculate progress\n        const progress = @as(f32, @floatFromInt(self.current)) / @as(f32, @floatFromInt(self.total));\n        const filled = @as(usize, @intFromFloat(progress * @as(f32, @floatFromInt(self.width))));\n\n        // Clear line\n        stdout.writeAll("\\r") catch return;\n\n        // Draw bar\n        stdout.writeAll("[") catch return;\n\n        var i: usize = 0;\n        while (i < self.width) : (i += 1) {\n            if (i < filled) {\n                // Color based on progress\n                const style = if (progress < 0.33)\n                    colors.red\n                else if (progress < 0.66)\n                    colors.yellow\n                else\n                    colors.green;\n\n                stdout.print("{}", .{style.call("\u2588")}) catch return;\n            } else {\n                stdout.print("{}", .{colors.dim.call("\u2591")}) catch return;\n            }\n        }\n\n        stdout.writeAll("]") catch return;\n\n        // Percentage\n        if (self.show_percentage) {\n            const percent = @as(u8, @intFromFloat(progress * 100));\n            stdout.print(" {}%", .{percent}) catch return;\n        }\n\n        // Time elapsed\n        if (self.show_time) {\n            const elapsed = std.time.milliTimestamp() - self.start_time;\n            const seconds = @divTrunc(elapsed, 1000);\n            stdout.print(" {}", .{colors.dim.call(std.fmt.comptimePrint(" [{d}s]", .{seconds}))}) catch return;\n        }\n\n        // Flush output\n        stdout.writeAll(" ") catch return;\n    }\n};\n\n// Usage\npub fn processFiles(files: []const []const u8) !void {\n    var progress = ProgressBar.init(files.len);\n\n    for (files) |file| {\n        // Process file...\n        std.time.sleep(100 * std.time.ns_per_ms); // Simulate work\n        progress.increment();\n    }\n\n    progress.finish();\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"interactive-menu",children:"Interactive Menu"}),"\n",(0,l.jsx)(n.p,{children:"A colorful interactive menu system:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-zig",children:'const std = @import("std");\nconst colors = @import("zig-colors");\n\npub const MenuItem = struct {\n    label: []const u8,\n    action: *const fn () void,\n    description: ?[]const u8 = null,\n};\n\npub const Menu = struct {\n    title: []const u8,\n    items: []const MenuItem,\n    selected: usize = 0,\n\n    const Self = @This();\n\n    pub fn draw(self: Self) void {\n        const stdout = std.io.getStdOut().writer();\n\n        // Clear screen (platform-specific)\n        stdout.writeAll("\\x1b[2J\\x1b[H") catch return;\n\n        // Title\n        const title_style = colors.bold.underline();\n        stdout.print("\\n  {}\\n\\n", .{title_style.call(self.title)}) catch return;\n\n        // Menu items\n        for (self.items, 0..) |item, i| {\n            if (i == self.selected) {\n                // Highlighted item\n                stdout.print("{} ", .{colors.cyan.call("\u25b6")}) catch return;\n                stdout.print("{}", .{colors.cyan.bold().call(item.label)}) catch return;\n\n                if (item.description) |desc| {\n                    stdout.print("\\n    {}", .{colors.dim.call(desc)}) catch return;\n                }\n            } else {\n                // Normal item\n                stdout.print("  {}", .{item.label}) catch return;\n            }\n            stdout.print("\\n", .{}) catch return;\n        }\n\n        // Instructions\n        stdout.print("\\n", .{}) catch return;\n        stdout.print("{} ", .{colors.dim.call("Use \u2191/\u2193 to navigate, Enter to select, Q to quit")}) catch return;\n    }\n\n    pub fn moveUp(self: *Self) void {\n        if (self.selected > 0) {\n            self.selected -= 1;\n        } else {\n            self.selected = self.items.len - 1;\n        }\n    }\n\n    pub fn moveDown(self: *Self) void {\n        self.selected = (self.selected + 1) % self.items.len;\n    }\n\n    pub fn select(self: Self) void {\n        self.items[self.selected].action();\n    }\n};\n\n// Usage\nfn action1() void {\n    std.debug.print("\\n{}\\n", .{colors.green.call("Starting backup...")});\n}\n\nfn action2() void {\n    std.debug.print("\\n{}\\n", .{colors.blue.call("Checking for updates...")});\n}\n\nfn action3() void {\n    std.debug.print("\\n{}\\n", .{colors.yellow.call("Cleaning cache...")});\n}\n\npub fn showMainMenu() void {\n    const items = [_]MenuItem{\n        .{ .label = "Backup Data", .action = action1, .description = "Create a full system backup" },\n        .{ .label = "Check Updates", .action = action2, .description = "Check for software updates" },\n        .{ .label = "Clean Cache", .action = action3, .description = "Remove temporary files" },\n    };\n\n    var menu = Menu{\n        .title = "System Maintenance",\n        .items = &items,\n    };\n\n    menu.draw();\n    // Handle input loop here...\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Always initialize"}),": Call ",(0,l.jsx)(n.code,{children:"colors.init()"})," at program start"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Check support"}),": Use ",(0,l.jsx)(n.code,{children:"colors.isSupported()"})," for graceful degradation"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Create semantic styles"}),": Define meaningful style constants for consistency"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Handle errors"}),": Color operations can fail on write, handle appropriately"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Clean up"}),": Call ",(0,l.jsx)(n.code,{children:"colors.deinit()"})," when done"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Test without colors"}),": Set ",(0,l.jsx)(n.code,{children:"NO_COLOR=1"})," environment variable to test fallbacks"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Review the ",(0,l.jsx)(n.a,{href:"/zig-colors-docs/api/colors",children:"API Reference"})," for complete method documentation"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(6540);const l={},r=s.createContext(l);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);